#!/bin/bash

set -o errexit

# We force the PATH to be the standard linux path in order to use the host's
# docker daemon instead of the result of docker-native. This avoids version
# mismatches
HOST_PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
DOCKER=$(PATH="$HOST_PATH" which docker)

sysroot="/"
tmpdir=""
shared_volume=""
shared_volume_path=""

while getopts 'i:o:s:t:v:p:' flag; do
	case "${flag}" in
        i) input=$(realpath "${OPTARG}") ;;
        o) output=$(realpath "${OPTARG}") ;;
        s) sysroot=$(realpath "${OPTARG}") ;;
        t) tmpdir=$(realpath "${OPTARG}") ;;
        v) shared_volume=${OPTARG} ;;
        p) shared_volume_path=$(realpath "${OPTARG}") ;;
        *) error "Unexpected option ${flag}" ;;
	esac
done

if [ -z "$tmpdir" ]; then
    echo "Missing tmpdir"
    exit 1
fi

if ! [ -f "$input" ]; then
    echo "File does not exist: $input"
    exit 1
fi

if ! [ -f "$output" ]; then
    echo "File does not exist: $output"
    exit 1
fi

cleanup_docker() {
    $DOCKER rmi @IMAGE@ || true
}

$DOCKER load -i "$sysroot/usr/share/mkfs-hostapp-ext4-image.tar"
trap cleanup_docker EXIT

mount_options="-v $input:/input:ro -v $tmpdir:$tmpdir:ro -v $output:/output"
if ! [ -z "${shared_volume}" ] && ! [ -z "${shared_volume_path}" ]; then
	if ($DOCKER volume inspect ${shared_volume} > /dev/null 2>/dev/null); then
		echo "mkfs.hostapp-ext4: Shared Docker volume option detected."

		mount_options="-v ${shared_volume}:${shared_volume_path}"
		mount_options="${mount_options} -e BUILD_INPUT=${input}"
		mount_options="${mount_options} -e BUILD_OUTPUT=${output}"
	fi
fi

$DOCKER run --privileged --rm ${mount_options} -e "PATH=$PATH:$HOST_PATH" @IMAGE@
